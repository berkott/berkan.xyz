import{t as f,a as w}from"../chunks/DKJMLC42.js";import"../chunks/BntcpoEZ.js";import{a as t,f as g,c as m,r as a,n as c}from"../chunks/BuAUvOro.js";import{h as e}from"../chunks/wXsJu9Ig.js";var x=f('<h1>Fun with bivariate Gaussians</h1> <p>Suppose I give you the following bivariate Gaussian distribution,</p> <div class="math math-display"><!></div> <p>Then I say “tell me sonny, if I drew a bunch of points from this distribution and plotted them, where about would they be?” I want a quick answer! You don’t even have time to run a Python simulation. What do you do?</p> <h2>Background</h2> <p>The mean vector is easy to understand, it’s just going to be the center of your distribution. The covariance matrix is the tricky part. Let’s recall some properties.</p> <ul><li>First off, it’s symmetric. Why? It comes straight from the definition of covariance and the commutativity of multiplication.</li> <li>Also, it’s positive semi-definite, meaning <span class="math math-inline"><!></span> for any <span class="math math-inline"><!></span>. Why? Because <span class="math math-inline"><!></span>.</li></ul> <p>Fun fact, the eigenvectors of a symmetric matrix are orthogonal!</p> <h2>Eigen stuff</h2> <p>Observe</p> <p>Eigenvalue stuff</p>',1);function I(h){var o=x(),i=t(g(o),4),d=m(i);e(d,()=>'<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">N</mi><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">(</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mtext> </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mtext> </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\\mathcal{N} \\Big(\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\begin{bmatrix} 3 \\ &amp; 1 \\\\ 1 \\ &amp; 2 \\end{bmatrix} \\Big).</annotation></semantics></math></span>'),a(i);var r=t(i,8),l=t(m(r),2),n=t(m(l)),v=m(n);e(v,()=>'<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="normal">Σ</mi><mi>v</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v^\\top \\Sigma v \\ge 0</annotation></semantics></math></span>'),a(n);var s=t(n,2),u=m(s);e(u,()=>'<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span>'),a(s);var p=t(s,2),y=m(p);e(y,()=>'<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="normal">Σ</mi><mi>v</mi><mo>=</mo><mtext>Var</mtext><mo stretchy="false">(</mo><msup><mi>v</mi><mi mathvariant="normal">⊤</mi></msup><mi>X</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v^\\top \\Sigma v = \\text{Var}(v^\\top X) \\ge 0</annotation></semantics></math></span>'),a(p),c(),a(l),a(r),c(8),w(h,o)}export{I as component};
